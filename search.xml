<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>那些我觉得很美很美的句子</title>
      <link href="/2018/02/27/sentences/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    平常看书的时候我有摘抄我觉得很美的句子的习惯，在此记录下来与大家分享。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p><contents></contents></p><p></p><p style="text-indent: 40px"><br>1.如此情深，却难以启齿。原来你若真爱一个人，内心酸涩，反而说不出话来，甜言蜜语，多数说给不相干的人听。 ——亦舒《她的二三事》<br>2.I am just a girl, standing in front of a boy, asking him to love me.——《诺丁山》<br>3.自幼贫民窟长大的女子，侥幸多念了两本书，枉以为可以与人平起平坐。可是人生从来都是接力赛，我们却天真的当成了百米冲刺。你我都是凡人，能冲出原始阶层的人极少，女子尤甚。在婚姻面前，爱情太渺小，真正的阻力并非他人的压力和低看，那是流淌在骨子里的基因，敏感，脆弱。 ——亦舒《承欢记》<br>4.你是我温暖的手套，冰冷的啤酒，带着阳光味道的衬衫，日复一日的梦想。——《恋爱的犀牛》<br>5.宿夕不梳头，素发披两肩。婉伸郎膝上，何处不可怜。<br>6.不是世界不好，是你见的太少<br>    ——我一直都很讨厌妄下判断与故作成熟这两件事。很多时候，我们轻易的判断某件事不好，没希望，没结果，不过是因为我们见的太少，或看见的东西层次不够。而仅仅凭借我们所见过的那些浅薄 世界，就去做出一脸的成熟去判断这个世界，其实并不明智。<br>    ——相信美好的东西，却仅仅是因为迷恋美好的东西给你的愉悦。承认缺陷，而不沉浸于缺陷与黑暗面可能带来的痛苦。<br>7.如果生命只是一场碎梦 我为什么还在追逐。如果人们看到我的背影，还会不会为这个傻瓜而感动。——汪峰《碎梦》<br>8.生命可以随心所欲但不能随波逐流。 ——宫崎骏<br>9.总有那么一首歌写着我们的曾经，我对你最深沉的爱，就是活成你的样子。 ——罗大佑<br>10.那是我们有梦，关于文学，关于爱情，关于穿越世界的旅行。如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。——北岛《波兰来客》</p><p>1.人生，其实无非是矛盾与选择的综合体，无关对错，仅仅在于我们能否有勇气在矛盾中作出选择并勇敢承担一切后果。——路遥《人生》<br>2.草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好。——顾城《门前》<br>3.我天性不宜交际。在多数场合，我不是觉得对方乏味，就是害怕对方觉得我乏味。可是我既不愿意忍受对方的乏味，也不愿费劲使自己显得有趣，那都太累了。我独处时最轻松，因为我不觉得自己乏味，即使乏味，也自己承受，不累及他人，无需感到不安。——周国平《人与永恒》<br>4.If I should see you，after long year.如果我们再相见，事隔经年。<br>How should I greet, with tears, with silence.我将以何贺你，以眼泪，以沉默。<br>5.我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。——王小波《爱你就像爱生命》</p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nextjs学习笔记(一)</title>
      <link href="/2018/01/30/180227next/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    本文由我一边看网上的nextjs的资源(原文网址:<a href="https://segmentfault.com/a/1190000010311978)，" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010311978)，</a><br>    一边根据自己的实际操作验证写成。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="nextjs"><a href="#nextjs" class="headerlink" title="nextjs"></a>nextjs</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Next.js是一个基于React实现的服务端渲染框架，github地址为<a href="https://github.com/zeit/next.js#fetching-data-and-component-lifecycle" target="_blank" rel="noopener">next.js</a>。无需书写webpack等配置文件。</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><p>与其他基于node的框架一样，mkdir-&gt;cd-&gt;init-&gt;install-&gt;mkdir-&gt;package.json-&gt;scripts-&gt;localhost://3000</p><ul><li>⚠️最后这里一定要创建pages目录哦，否则会报错的,如下。这是因为Next.js采用的是文件系统作为API，每一个放在pages中的文件都会映射为一个路由，路由名称与文件名相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LynndeMacBook-Pro:myapp lynn$ npm run dev</span><br><span class="line"></span><br><span class="line">&gt; my-app@0.1.0 dev /Users/lynn/Desktop/myapp</span><br><span class="line">&gt; next</span><br><span class="line"></span><br><span class="line">&gt; Couldn&apos;t find a `pages` directory. Please create one under the project root</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! my-app@0.1.0 dev: `next`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the my-app@0.1.0 dev script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br></pre></td></tr></table></figure></li></ul><p>index.js(我也不知道为什么一定要命名为index.js,总之我现在这样写成其他名字是不行的，也许是因为在编译的时候源文件的名字就是index.js。run之后会自动生成.next目录，包含了打包，es6的编译。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;//这一句非常重要</span><br><span class="line">export default () =&gt; (</span><br><span class="line">    &lt;h1&gt;Hello Next.js&lt;/h1&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="页面导航Link"><a href="#页面导航Link" class="headerlink" title="页面导航Link"></a>页面导航Link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Link from &apos;next/link&apos;</span><br><span class="line">export default () =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Link href=&quot;/about&quot; &gt;</span><br><span class="line">            &lt;a&gt;About Page&lt;/a&gt;</span><br><span class="line">        &lt;/Link&gt;</span><br><span class="line">        &lt;h1&gt;Hello Next.js&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="公用组件component"><a href="#公用组件component" class="headerlink" title="公用组件component"></a>公用组件component</h3><p>⚠️非常重要的一点是自己定义的组件的首字母一定要大写<br>import的顺序不重要</p><h4 id="Header-js"><a href="#Header-js" class="headerlink" title="Header.js"></a>Header.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Link from &apos;next/link&apos;;</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">const listStyle = &#123;</span><br><span class="line">    marginRight: 15</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default () =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Link href = &quot;/&quot;&gt;</span><br><span class="line">            &lt;a style=&#123;listStyle&#125;&gt;Home&lt;/a&gt;</span><br><span class="line">        &lt;/Link&gt;</span><br><span class="line">        &lt;Link href = &quot;/about&quot;&gt;</span><br><span class="line">            &lt;a style=&#123;listStyle&#125;&gt;About&lt;/a&gt;</span><br><span class="line">        &lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Layout-js"><a href="#Layout-js" class="headerlink" title="Layout.js"></a>Layout.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import Header from &apos;./header&apos;;</span><br><span class="line"></span><br><span class="line">const layoutStyle = &#123;</span><br><span class="line">    margin: 20,</span><br><span class="line">    padding: 20,</span><br><span class="line">    border: &apos;1px solid #ddd&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default (props) =&gt; (</span><br><span class="line">    &lt;div style = &#123;layoutStyle&#125;&gt;</span><br><span class="line">        &lt;Header /&gt;//此时就可以使用Header标签了，index.js中的layout也是同样的道理</span><br><span class="line">        &#123;props.children&#125;//组件嵌套时父组件用它来将所有组件显示出来，所有上面会有参数的传递</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import Layout from &apos;../component/layout.js&apos;;</span><br><span class="line">export default () =&gt; (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">        &lt;h1&gt;Hello Next.js&lt;/h1&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="动态页面"><a href="#动态页面" class="headerlink" title="动态页面"></a>动态页面</h3><h4 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h4><ul><li>as属性的作用是更改路由的名称,现在的地址栏的地址显示为<a href="http://localhost:3000/p/learn-nextjs。而如果不使用as属性，它会直接显示href的值http://localhost:3000/post?id=hello-nextjs" target="_blank" rel="noopener">http://localhost:3000/p/learn-nextjs。而如果不使用as属性，它会直接显示href的值http://localhost:3000/post?id=hello-nextjs</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import Layout from &apos;../components/layout.js&apos;</span><br><span class="line">import Link from &apos;next/link&apos;</span><br><span class="line"></span><br><span class="line">const PostLink = (props) =&gt; (</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;Link as=&#123;`/p/$&#123;props.id&#125;`&#125;  href=&#123;`/post?id=$&#123;props.id&#125;`&#125;</span><br><span class="line">      &lt;a&gt;&#123;props.id&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">)</span><br><span class="line">export default () =&gt; (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">    &lt;h1&gt;My Blog&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;PostLink id=&quot;hello-nextjs&quot; /&gt;</span><br><span class="line">      &lt;PostLink id=&quot;learn-nextjs&quot; /&gt;</span><br><span class="line">      &lt;PostLink id=&quot;deploy-nextjs&quot; /&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/Layout&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="post-js"><a href="#post-js" class="headerlink" title="post.js"></a>post.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Layout from &apos;../components/Layout.js&apos;</span><br><span class="line">export default (props) =&gt; (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">       &lt;h1&gt;&#123;props.url.query.id&#125;&lt;/h1&gt;//从url.query.id中拿到页面传过来的id</span><br><span class="line">       &lt;p&gt;This is the post page.&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> nextjs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟教程——HTML</title>
      <link href="/2018/01/29/180227html/"/>
      <content type="html"><![CDATA[<hr><p><excerpt in="" index="" |="" 首页摘要=""><br>    本文由我一边看菜鸟教程中的html教程(原文网址:<a href="https://segmentfault.com/a/1190000010311978)，" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010311978)，</a> 一边根据自己的实际操作验证写成。其中包括一些我觉得可能需要注意的点，以及在实际操作之后总结的一些经验。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h3 id="1-html简介"><a href="#1-html简介" class="headerlink" title="1.html简介"></a>1.html简介</h3><ul><li><html>表示页面的跟元素，也就是dom节点中的root根节点</html></li><li><head>元素包含文档的元数据(<a href="http://blog.csdn.net/yjh314/article/details/53404797),文档的特征数据，比如编码方式、标题等。" target="_blank" rel="noopener">http://blog.csdn.net/yjh314/article/details/53404797),文档的特征数据，比如编码方式、标题等。</a></head></li><li>编码格式，<code>meta charest=&quot;utf-8&quot;</code>当不写这个时候在chrome浏览器中并没有出现问题，但是在safari浏览器中出现乱码问题。<h3 id="2-html编辑器"><a href="#2-html编辑器" class="headerlink" title="2.html编辑器"></a>2.html编辑器</h3></li><li>emmet插件(x<a href="http://www.iteye.com/news/27580)很多快捷方式的使用可以大大提高我们的编码速度" target="_blank" rel="noopener">http://www.iteye.com/news/27580)很多快捷方式的使用可以大大提高我们的编码速度</a></li><li>GPL<h3 id="3-h1～h6"><a href="#3-h1～h6" class="headerlink" title="3.h1～h6"></a>3.h1～h6</h3></li><li>在标题中，会有明显的空行，也许是在编写标签的时候就已经将换行加入其中。段落同样也有这样的特性</li><li>1到6号标题与1到6号字体逆序对应，比如1号字体对应6号标题，2号字体对应5号标题。<code>font size = &quot;1&quot;</code>设置字体大小<h3 id="4-格式化标签"><a href="#4-格式化标签" class="headerlink" title="4.格式化标签"></a>4.格式化标签</h3>通常标签<code>&lt;strong&gt;</code>替换加粗标签<code>&lt;b&gt;</code>来使用,<code>&lt;em&gt;</code>替换<code>&lt;i&gt;</code>标签使用。然而，这些标签的含义是不同的：<code>&lt;b&gt;</code>与<code>&lt;i&gt;</code>定义粗体或斜体文本。<code>&lt;strong&gt;</code>或者<code>&lt;em&gt;</code>意味着你要呈现的文本是重要的，所以要突出显示。</li><li>b(bold)-&gt;strong加粗字体</li><li>i(italic)-&gt;em倾斜字体</li><li>small缩小字体</li><li>big放大字体</li><li>pre(prepare)预排版</li><li>sub(subscript)下标</li><li>sup(superior)上标</li><li>address地址，会以斜体的格式呈现</li><li>q(quote)引用，文字会自动加上双引号</li><li>ins(insert)定义插入文字，会有下划线效果</li><li>u(underline)下划线效果</li><li>del(delete)定义删除字，会在文字中间有一条删除线<h3 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h3>超链接并不一定是一个html地址，也有可能只是指向一段文字，一张图片，一个地址等等。</li><li>id，也就是可以设置锚点，指向指定的位置</li><li>target，打开超链接的方式，另外target还可以指定打开的页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.baidu.com&quot; frameborder=&quot;0&quot; width=&quot;400px&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot; target=&quot;iframe_a&quot;&gt;显示到上面的框架中&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">//点击链接，iframe中将会显示a标签指定的链接</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#C4&gt;&quot;&gt;指向章节4&lt;/a&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;#C4&quot;&gt;查看章节 4&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节一&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节一的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节二&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节二的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节三&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节三的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;&lt;a id=&quot;C4&quot;&gt;章节四&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节四的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节五&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节五的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节六&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节六的内容&lt;/p&gt;</span><br><span class="line">&lt;h2&gt;章节七&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这里显示的是章节七的内容&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，不加p标签的a链接并没有起到任何作用，并不知道是为什么。另外，如果像上面这样页面可以放下所有的内容，可能看不出来显示的效果。但是如果有了滚动条且内容足够多的时候，就会明显看出来章节4的内容显示在了浏览器的头部位置，如果虽然有滚动条，但是内容并不是很多，则会走到滚动条的尽头。</p><h3 id="6-邮件发送"><a href="#6-邮件发送" class="headerlink" title="6.邮件发送"></a>6.邮件发送</h3><ul><li>mailto发送邮件的方式</li><li>cc抄送</li><li>subject主题</li><li>body邮件正文<h3 id="7-base标签"><a href="#7-base标签" class="headerlink" title="7.base标签"></a>7.base标签</h3></li><li>base标签，基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接。也就是说如果一个a标签没有指定href属性，那么它会指向base的href属性中的链接。并且可以定义所有标签的默认属性，比如target=_blank，那么所有链接都会在新的页面打开<h3 id="8-图像映射"><a href="#8-图像映射" class="headerlink" title="8.图像映射"></a>8.图像映射</h3>图像映射指的是带有可点击区域的图像</li><li>usemap与map中的name属性对应</li><li>area定义映射区域，也就是图像中可点击的区域。包含shape、coords(coordinate)、href和alt属性等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; alt=&quot;猫咪&quot; usemap=&quot;cat&quot;&gt;</span><br><span class="line">    &lt;map name=&quot;cat&quot;&gt;</span><br><span class="line">        &lt;area shape=&quot;circle&quot; coords=&quot;200,300,60&quot; href=&quot;http://www.baidu.com&quot; alt=&quot;百度&quot;&gt;//圆心为(200,300)半径为60的圆形</span><br><span class="line">        &lt;area shape=&quot;rectangle&quot; coords=&quot;12,16,22,26&quot; href=&quot;http://www.runoob.com&quot; alt=&quot;菜鸟教程&quot;&gt;//左上顶点为(12,16),右上顶点为(22,26)的矩形</span><br><span class="line">    &lt;/map&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h3><ul><li>table表格的开始</li><li>tr(table row)一行的开始，有几个就有几行</li><li>td(table date)单元格中的数据，也可以说有几个就有几列</li><li>th(table head)表格头</li><li>caption表格的标题</li><li>colspan，定义横向合并几个单元格</li><li>rowspan，定义纵向合并几个单元格</li><li>cellspacing，单元格之间的距离</li><li>cellpadding，内容与表格边框之间的距离</li><li>colgroup额外的定义表格的样式与col配合</li><li>thead ———表格的页眉</li><li>tbody ———表格的主体</li><li>tfoot ———定义表格的页脚<br><img src="http://www.runoob.com/wp-content/uploads/2014/08/learn-html5-tables-5-638.jpg" alt="image"><h3 id="10-列表"><a href="#10-列表" class="headerlink" title="10.列表"></a>10.列表</h3></li><li>发现一个有意思的现象，如果我定义了一个嵌套的无序列表，那么他们的前面的小点点是从实心原点、空心原点、实心方框这样的顺序表示的。</li><li>自定义列表，类似于table表格,dl(define list)、dt(define)和dd(define data/description)<h3 id="11-特殊知识"><a href="#11-特殊知识" class="headerlink" title="11.特殊知识"></a>11.特殊知识</h3></li><li>web安全色</li><li><a href="http://www.runoob.com/html/html-colornames.html" target="_blank" rel="noopener">141颜色名称</a>，是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。</li><li><a href="http://www.runoob.com/tags/ref-entities.html" target="_blank" rel="noopener">字符实体</a>,大小写敏感<code>&amp;nbsp;-&gt;(non-breaking space)</code><h3 id="12-url-uniform-resource-locator"><a href="#12-url-uniform-resource-locator" class="headerlink" title="12.url(uniform resource locator)"></a>12.url(uniform resource locator)</h3>scheme://host.domain:port/path/filename</li><li>scheme,因特网服务类型，比如http,https,ftp,file(本地)</li><li>host，主机名，默认是www</li><li>domain，域名，</li><li>post，主机上的端口号</li><li>path，服务器上的路径</li><li>filename，文件名</li><li>url使用ascii字符编码集，使用”%”其后跟随两位的十六进制数来替换非ASCII字符。不能包含空格。通常使用 + 来替换空格。</li><li><a href="https://www.cnblogs.com/xk-bench/p/7543500.html" target="_blank" rel="noopener">url中一些字符的作用</a>,比如&amp;表示几个并列参数之间的连接。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>我想和你好好的</title>
      <link href="/2017/12/02/180102/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    《我想和你好好的》+《面纱》+ 《世间始终你好》观后感——记我对爱情的一点点儿浅薄的理解<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>偶然听到宋冬野的《平淡日子里的刺》很有感触，因取自原声带，饶有兴趣的去看了相关的电影《我想和你好好的》。该片豆瓣评分并不是很高，也许单身的人看了，都不想拥有一个女朋友吧。首先说说男主吧，从最开始就袒露了自己渣男的本质，不主动，不拒绝，不负责，但是从片子本身透露出的来看，体现的更多的是他对前女友的态度，照片，东西，大半夜给她送东西，以及后面和她的做爱。但是他又是爱女主的，为他紧张，被他管着，为他做饭，收起自己爱玩爱闹的心。偶尔同情男主。但是从他来看，他确实没有带给女生太多安全感，很多事情并不是嘴上说说就可以。从女主的角度，则觉得她确实很作，可是一个女孩子这样对你，不过是太过爱你，想和你一起生活，一起好好的生活，你可以有朋友，有自己的生活，但是我一定是你的唯一，我讨厌你有那么多过去，讨厌有人来分享你的爱，不管是朋友还是女生，讨厌你大半夜为了你的前女友特地跑出去，讨厌你烦心时需要的是他，讨厌你对我说谎，讨厌你让我如此爱你而丧失了自我。男主习惯了这样单调的生活，习惯了每天睡觉抱着女主的姿势。也许每个男孩子都要经历这么一个让你难忘的女孩子，才会真正成长为一个男人，也许每个女孩子都会经历这么一个让你如此奋不顾身的男人，才会变成更加独立成熟的人格。他的幼稚我的固执，都成为历史。<br>犹记得高中时非常喜欢“庭有枇杷树，吾妻死之年所植也，今已亭亭如盖矣”（出自归有光《项脊轩志》）读来非常感动，但是在前一阵，偶然得知，在妻子死之后，归有光又有了很多任妻子，很多人为此而声讨他，个人觉得其实这也很正常。爱情不应该是如此自私的。一生中可以喜欢很多人，但让你心疼的只有一个。如果激情退却之后，两个人在一起剩下的只有折磨，倒不如从此各安天涯，岁月安好。B站中曾经有人也为此文写过一段很动人的话，“有枇杷树,吾妻死之年所手植也,今已亭亭如盖矣。今伐之，为搏小娘子一笑。小娘子一笑，正若吾妻年少时。小娘子为吾妻与吾之女，今伐树，为小娘子造出嫁之物，愿伉俪情深，不输吾与亡妻。”开始认真的思考，到底什么样的相处模式才是爱情中最好的。<br>《面纱》这部小说中瓦尔特的深情告白曾经深深触动过我“我知道你愚蠢、轻浮、没有头脑，但是我爱你。我知道你的目标和理想既庸俗又普通，但是我爱你。我知道你是二流货色，但是我爱你。想一想真是好笑，我竭力去喜欢那些讨你喜欢的东西，忍受折磨也要对你隐瞒起自己，实际上我并不无知粗俗、不爱散播丑闻也不愚蠢。我知道你何等害怕智慧，便尽我所能让你觉得我是个大傻瓜，跟你认识的其他人一样。我知道你嫁给我只图一时利益，我是那样爱你，我不在乎。大多数人，就我所知，当他们爱一个人，却没有得到爱的回报时就会觉得委屈不平，甚至愈发愤怒和痛苦。我不是那样，我从来没有指望你爱我，我看不出任何理由让你爱我，我也从来没想过自己会被人爱。我很感激能被允许爱你，当我时常想起你高兴跟我在一起，或者当我发现你眼中闪烁着愉快的爱意时，我就会欣喜若狂。我尽量不让我的爱来烦扰你，我知道那会让我承受不起，所以我一直察言观色，留意我的爱让你厌烦的最初迹象。大部分丈夫认为那是一种权力，我却准备当成恩惠来接受。”。究竟是多深的爱，才能让一个人如此卑微。其实看完面纱以后，心里一直不是很舒服，突然对爱情产生了疑惑。我们决定和某个人结婚的原因到底是什么，像凯蒂一样的迫不得已而选择一个深爱自己的人么？当对年龄的恐惧和外人的闲言碎语将你包围的时候，你会不会选择一个合适的人而草草度过一生呢？我们总想遇到一个对的人，但是，每个人心里对对的人的标准都不一样，我也不知道什么样的人才是对的人。也许曾经遇到喜欢的人，你也曾经幻想过他或许就是你对的人，你用你脑海中仅存的小说和电视剧中的情节，幻想着，也许我们能共同度过今后漫长的人生之路。可是那个人，也许只是你生命中的一个过客而已，转眼就消失在你的生命中。分手后不做朋友挺好的，断了我们曾经所有的幻想，从今以后认真的开始新的生活。曾经的人教会我们成长，去变成一个不一样的，成熟的女孩。就像凯蒂一样，虽然我们曾经迷恋完美的肉体，动听的情话，但是当我们清楚的意识到自己在他心中的位置的时候，终究会学会成长。一直觉得，很多时候，女孩子在感情中，是弱势的一方，女生太容易付出自己的感情，一切，然而这些在男生的眼中，越多的主动，反而失去了探索的兴趣。我从不希望自己是一杯无味的白开水，也不希望自己是一杯碳酸饮料，将自己的热情释放完后，剩下的是什么，希望自己是一杯浓烈的酒，让人喝了，会醉。<br>最近恰好也看完了不知道在哪里了解到的《世间始终你好》(劳伦·弗莱施曼)，55对来自美国各地结婚至少50年的夫妻，也许我的年纪还不太能懂他们那种一辈子的婚姻，有时觉得一生太过漫长，有着太多的未知。也许那时的爱情会受到更多的来自于家庭、宗教、种族等地束缚，也有疾病和贫穷，也会争吵不休，但他们依然能携手度过一生。那时的女性大多步入婚姻，便将丈夫和孩子作为自己的重心，那时有什么问题会想着如何去修修补补，而现在的我们多想着去换一个新的。书中并没有提到什么浪漫的情节，反而更多的是生活中的琐事，娓娓道来。也许大多数爱情都是在经历过开始的激情过后，归于剩下平平淡淡的生活，也许这才是婚姻的本质。爱情过后，更多的是习惯和依赖，不在嘴上说我爱你，只想在生活中和你好好的在一起。始于感觉，陷于才华，忠于人品。也许最舒服的就是最好的吧。</the></p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《坦白书》读书笔记</title>
      <link href="/2017/07/20/20170720/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    我所有的自负皆来自我的自卑，所有的英雄气概都来自于我的软弱。嘴里振振有词是因为心里满是怀疑，深情是因为痛恨自己无情。这世界没有一件事情是虚空而生的，站在光里，背后就会有阴影。这深夜里一片寂寞，是因为你还没有听见声音。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p><contents></contents></p><p></p><p style="text-indent: 40px"><br><strong>p2.1.</strong>我要在你平庸无奇的回忆里做一个闪闪发光的神经病。<br><strong>p6.2.</strong>我的身体里住过我一生至今每个冬天的雪，住过大海，住过这世间所有流浪的爱人。<br><strong>p17.3.</strong>就像生命力里所有的甜蜜和酸楚总是结伴而行，而疼痛总是四处追逐着快乐，片刻也不愿分开。<br><strong>p19.4.</strong>有些词在人生里是有时态的，过一定的年纪之后，这个词便和你无关了，和知了的聒噪声一样，远离了这个城市的夏天，从此属于回忆的一部分。我和所有过了保质期的少年一样，就这样自以为是的长大成人，和童话书以及书页里夹藏的所有秘密，从此分道扬镳，此生不再相遇。于是，在这个恍如隔世的夏夜，我又看到了小时候的自己，还躺在那时光里，已经死了很久很久，比我后来所经历的人生还要久，而那些些消失在书页里的花儿和蝴蝶，在那方舞台上漫天地飞舞。原来他们一直在那儿，一直陪着那寂寞的小小少年。<br><strong>p20.5.</strong>然后，我也永远记住了那种愚蠢地夺去别人生命的耻辱和最后遭到的报应。很多年以后，我还做过一个噩梦，我梦见自己就是那只小老鼠，在无数的雨点般跺下来的脚里，拼命地奔逃，烟尘滚滚，四面楚歌，我也不知道能不能逃掉，拼命地跑。再后来，我发现我们都是在跑，这个世界上谁也逃不掉。<br><strong>p25.6.</strong>他总是微笑告诉我，以后无论生活强加于你什么，都不能被挫折改变，应该保有自己的尊严和态度，这才是真正的绅士。<br><strong>p29.7.</strong>童年的痛苦在于，你总是无法说出你想说的话。长大后你可以说了，却没什么好说的了，不愿意说了，或者是不敢说了。我们的生命因为有死亡的存在，在本质上说是束缚和被定义的，人和人完全相互理解是很难的。那些不为人知的青春爱欲，成长的脆弱、酸楚和甜蜜，其实永远只属于你自己，如同草叶静静生长，然后静静地枯萎。我常常回忆起自己的过去，那些时光像是博物馆橱窗里的标本，安静，死寂。我们身处这个超速的时代，那曾经历过的生活，回头看已变得似是而非。它正以某种荒诞的速度，飞速地从我们的记忆力逃之夭夭,根本无法捉住它。只有在相互遗忘之前，用想象弥补初一个亦真亦幻的过去，沉溺其中片刻以获得某种温情的安抚，似乎时间从没有离弃过我，一切事物都可以坦然地归于最开始的地方，安静从容。乐此不疲于这一场时光旅行的游戏。虽然我也知道这是徒劳的。<br><strong>p55.6.</strong>毛姆曾经写过，今天我已经认识到这一点：卑鄙与伟大，恶毒与善良，仇恨和热爱是可以不排斥的存在同一颗心里的。所以，亲爱的朋友，请原谅我吧！对此，至少有一半的我是值得的。<br>——我所有的自负皆来自我的自卑，所有的英雄气概都来自于我的软弱。嘴里振振有词是因为心里满是怀疑，深情是因为痛恨自己无情。这世界没有一件事情是虚空而生的，站在光里，背后就会有阴影。这深夜里一片寂寞，是因为你还没有听见声音。<br>——每次见到不善言辞的年轻人，总很小心翼翼不多说话，希望不要因为自己的饶舌而让他们自卑。如今我终于明白，会说话并不是件必须的事情，生活志海，长风击浪固然风流，在水下深潜也是件美妙的事情。一直很怀念自己口不能言一个人沉在水底的青春岁月，后悔太早挣扎着想浮上来。如今阳光之下并无新事。眼看着手里值钱的东西，莫不是都来自那时光的沉默深处。只可惜早早学了弄潮儿，带出来的所剩无几。<br><strong>p65.9</strong>请给我一个温柔的理由吧，让我宽恕这个我如此深爱却几乎杀了我的世界。<br><strong>p66.10.</strong>所谓才华是不存在的。艺术创作只是选择了一种生活，瞪大眼睛，无论眼睛里看到了多少伤悲，有多少风沙迷雾只能狠狠地看着。把内心和盘托出，无论它多么敏感柔软，是把生命里的每一秒每一个瞬间都细细咀嚼，无论是蜜糖还是毒鸩都咽下去。没有平静可言，这是一条正常生活的背道之徒，精神上的亡命而已。<br><strong>p68.11.</strong>每次想到在有限的生命里，竟要被那些傻逼的人和事所束缚，便会油然而生一种没来由的斗志，瞬间满血复活。<br>——这世界每天产生很多很多的微小如尘埃的情感和秘密。只和当事人有关，随后就被时间洪流埋葬了。无关的我们无须也无法关注，因为我们自己也有无数的随流沙而去的情感来不及握住。但他们还是如此动人，尤其偶然从时光里惊鸿一瞥间。<br><strong>p74.12.</strong>一个生活里的小人物做着自己认为浪漫的工作，为陌生的人送信传情，尽管只是个邮差，但他自己觉得他自己是个温暖又重要的人。他有时觉得自己是个伟大的英雄，可以穿墙可以可以飞天，但有时他也知道自己只是一条落网的胖鱼，无处可逃；但信还是终归要送的，这是他的工作。<br>我一直觉得，这个世界本来的面目是索然无味的，还好我们有幻觉和想象力，它们在潜意识里辛苦地织补着我们破绽百出的生活，使之柔和并让人眷恋一些。<br><strong>p75.13.</strong>是烟云，是泡沫，也是一小勺膨胀出来的巨大的甜蜜和幸福。我想起了两年前写下的这句话，我一直很喜欢这句话，对此常常有些“自恋”。生活里很多东西都是会破灭的，但不妨碍我们相信生活在美好的幻觉里，享受幻觉放大的幸福感。人往往会先给自己算个卦，然后就心甘情愿地照这个卦象生活，所以我们要做个会作弊者，只给自己抽一根上上签，不好的就直接扔掉，读也别读，想都别再想。<br><strong>p77.14.</strong>生命只是一场寂寥的马戏，我们孤独地表演着自己。即使这只是一场寂寥的马戏，我们依然要活色生香地演下去。<br><strong>p82.14.</strong>我们站在舞台上，世界的手把帷幕慢慢地拉开，一开始有点刺眼，渐渐就可以看清楚了，幕布之外那未曾见过的一切，让人喜不自禁，可惜那只手不曾停下来。之后他会很慢很慢地合上大幕，人的一生就是这样。当你正面对完全打开的世界的时候，一定要好好地享受，拼命地记得。因为之后阴影将追着你，无处可逃。<br><strong>p85.14.</strong>所有的自我毁灭都带有极端的美感，但仅仅为了美感或者或死去都不太靠谱。大部分时候，所谓生活的抉择，无非就是选择要在一场古典悲剧里演一个执迷不悔的小丑，或是在一出肥皂剧里演一个愚蠢的没有悬念的英雄。<br><strong>p88.15.</strong>生活本身就是很现实的，每靠近完美一分便要付出一分的代价。浪漫的背后往往是最不浪漫的消磨，所以生活里仅存的那点儿浪漫才显得尤其可贵。努力存住那种情缘赴汤蹈火的勇敢吧，像护住那风中之烛，不能任其灭了。你知道的，那是我们获得幸福的唯一希望。<br><strong>p111.16.</strong>这时间最美丽却也残酷的一切，总是来去如朝雾，亦如闪电，于是我开始相信爱和自由，只存在于惊鸿一瞥间。<br><strong>p112.17.</strong>如果我们的生活里，没有痛苦，将不会更好，而会更糟，因为这样我们将不曾有过幸福，有过希望。《潜行者》塔科夫斯基</p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The art of writing small and plain functions</title>
      <link href="/2016/09/12/zbj180227/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>     曾经在实习的时候徽大大布置的任务，其中部分由徽大大翻译，部分由我翻译。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>原文地址：<a href="https://rainsoft.io/the-art-of-writing-small-and-plain-functions/?utm_source=codropscollective" target="_blank" rel="noopener">https://rainsoft.io/the-art-of-writing-small-and-plain-functions/?utm_source=codropscollective</a></the></p><p>The complexity of software applications is growing. The code quality is important in order to make the application stable and easily extensible.</p><p>随着应用软件的复杂度的不断增长，代码的质量在增加应用的稳定性和易扩展性方面起到了至关重要的作用。</p><p>Unfortunately almost every developer, including myself, in his career faced with bad quality code. And it’s a swamp. Such code has the following harmful characteristics:</p><p>然而不幸的是，包括我自己在内的每一位开发者在其职业生涯中都要不可避免地面对一些糟糕的代码。这些代码都有如下的不好的特点： </p><ol><li>Functions are too long and do too many things </li><li>Often functions have side effects that are difficult to understand or even debug </li><li>Unclear naming of functions and variables</li><li>Fragile code: a small modification unexpectedly breaks other application components</li><li>Poor or missing code coverage</li></ol><p>1.函数太长且实现了太多的功能</p><p>2.难以理解和调试</p><p>3.复杂多样的函数名称和变量声明</p><p>4.脆弱的代码：一个小小的修改可能会意外的导致其他组件崩溃</p><p>5.代码测试覆盖率低</p><p>It sounds very common: “I don’t understand how this code works”, “this code is a mess”,”it’s hard to modify this code” and the like.</p><p>我们可能经常会听到：“我真的不明白这个代码是如何执行的”，“这个代码真是坑”，“这个代码太难改了”诸如此类的抱怨。</p><p>Once I had a situation when my colleague quit his job because he dealt with a REST API on Ruby that was hard to maintain. He received this project from previous team of developers. </p><p>曾经有一次我的同事放弃了他的工作，只因为他要处理的一个用Ruby编写的REST API太难维护。而那个项目是由之前的开发团队手中接手的。</p><p>Fixing current bugs creates new ones, adding new features creates a new series of bugs and so on (fragile code). The client didn’t want to rebuild the application with a better design, and the developer made the correct decision to quit.</p><p>修改现有的bug会产生新的更多的bugs，添加一个新的功能会引发一连串的连锁反应，产生很多bugs等等诸如此类的情况（这也就是我们所说的fragile codes）。如果客户不想重构更好的应用设计，那么作为开发者最明智的决定就是退出。</p><p>Ok, such situations happen often and are sad. But what do to?</p><p>好吧，这个坑就是这样无处不在让人头疼，那么作为程序开发者的我们，该如何去应对或者说尽量避免这种情况的发生呢？</p><p>The first to keep in mind: simply making the application run and taking care of the code quality are different tasks.</p><p>牢记在心的一件事：代码的可运行性和注重代码质量是两件事。</p><p>On one side you implement the app requirements. But on the other side you should take time to verify if any function doesn’t have too much responsibility, write comprehensive variable and function names, avoid functions with side effects and so on.</p><p>一方面你需要完成应用开发需求，但是另一方面你要花时间去验证某个函数是否做了很多事情。命名容易理解的变量和函数名称，避免函数的耦合性等等。</p><p>The functions (including object methods) are the little gears that make the application run. First you should concentrate on their structure and composition. The current article covers best practices how to write plain, understandable and easy to test functions.</p><p>函数（包括对象方法）是保证应用运行的最小单元。首先你应该专注于他们的结构和组成。本文将通过实例很好的讲述了如何写出一个单一可读和可测试的函数。</p><h3 id="Functions-should-be-small-Really-small-函数要小且足够的小"><a href="#Functions-should-be-small-Really-small-函数要小且足够的小" class="headerlink" title="Functions should be small. Really small 函数要小且足够的小"></a>Functions should be small. Really small 函数要小且足够的小</h3><p>Big functions that have a lot of responsibility should be avoided and split into small ones. Big black box functions are difficult to understand, modify and especially test.</p><p>我们应该避免庞大的拥有很多功能的大函数，应该将其分解成相应的小函数。庞大的黑盒函数是很不可读，难以修改和不易测试的。</p><p>Suppose a scenario when a function should return the weight of an array, map or plain JavaScript object. The weight is calculated by summing the property values:</p><p>假设一个场景：当一个功能函数需要通过返回数组，map或者简单的js对象的值。而这个值是通过所有属性值的和而得到的。</p><ul><li>1 point for null or undefined </li><li>2 points for a primitive type</li><li>4 points for an object or function.</li><li>未定义和null值表示1分</li><li>一个简单对象是2分（含有零个或多个的key/value对）</li><li>函数和自定义对象是4分</li></ul><p>For example the weight of an array [null, ‘Hello World’, {}] is calculated this way: 1 (for null) + 2 (for string primitive type) + 4 (for an object) = 7.</p><p>例如一个对象集合是 [null,’hello world’,{}],计算公式是：1(for null) + 2(for string) + 4（for an object）= 7</p><h3 id="Step-0-The-initial-big-function-原始的庞大函数"><a href="#Step-0-The-initial-big-function-原始的庞大函数" class="headerlink" title="Step 0: The initial big function 原始的庞大函数"></a>Step 0: The initial big function 原始的庞大函数</h3><p>Let’s start with the worst practice. The logic is coded within a single big function</p><p>让我们从一个反面例子开始。将所有逻辑放在一个庞大的函数里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getCollectionWeight(collection) &#123;  </span><br><span class="line">    let collectionValues;</span><br><span class="line">    if (collection instanceof Array) &#123;</span><br><span class="line">        collectionValues = collection;</span><br><span class="line">    &#125; else if (collection instanceof Map) &#123;</span><br><span class="line">        collectionValues = [...collection.values()];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        collectionValues = Object.keys(collection).map(function (key) &#123;</span><br><span class="line">            return collection[key];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return collectionValues.reduce(function(sum, item) &#123;</span><br><span class="line">        if (item == null) &#123;</span><br><span class="line">            return sum + 1;</span><br><span class="line">        &#125; </span><br><span class="line">        if (typeof item === &apos;object&apos; || typeof item === &apos;function&apos;) &#123;</span><br><span class="line">            return sum + 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum + 2;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">let myArray = [null, &#123; &#125;, 15];  </span><br><span class="line">let myMap = new Map([ [&apos;functionKey&apos;, function() &#123;&#125;] ]);  </span><br><span class="line">let myObject = &#123; &apos;stringKey&apos;: &apos;Hello world&apos; &#125;;  </span><br><span class="line">getCollectionWeight(myArray);  // =&gt; 7 (1 + 4 + 2)  </span><br><span class="line">getCollectionWeight(myMap);    // =&gt; 4  </span><br><span class="line">getCollectionWeight(myObject); // =&gt; 2</span><br></pre></td></tr></table></figure><p>The problem is clearly visible. getCollectionWeight() function is too big and looks like a black box full of surprises.</p><p>这个问题很明确。getCollectionWeight()函数太大并且看起来像一个充满惊喜的黑洞</p><p>You probably find it difficult to understand what it does from the first sight. And imagine a bunch of such functions in an application.</p><p>当你第一眼看到他的时候你可能很难理解他到底在干嘛。想象一下在你的应用中有这样一大坨函数。</p><p>When you work with such code, you waste time and effort. On the other side the quality code doesn’t make you feel uncomfortable. Quality code with small and self-explanatory functions is a pleasure to read and easy to follow.</p><p>当你处理这种代码的时候，你会花费很多精力和时间。另外，这种质量的代码让人看起来很不爽。因为去阅读和理解易懂简小的高质量代码本身就是一种美的享受。</p><h3 id="Step-1-Extract-weight-by-type-and-drop-magic-numbers按照参数和类型简化代码的权重"><a href="#Step-1-Extract-weight-by-type-and-drop-magic-numbers按照参数和类型简化代码的权重" class="headerlink" title="Step 1: Extract weight by type and drop magic numbers按照参数和类型简化代码的权重"></a>Step 1: Extract weight by type and drop magic numbers按照参数和类型简化代码的权重</h3><p>Now the goal is to split the big function into smaller, independent and reusable ones. The first step is to extract the code that determines the weight of a value by its type. This new function will be named getWeight().</p><p>现在我们的目标是将整个大函数分割成小的独立的、可重用的函数。第一步就是分析代码将获取类型的大小值的功能分割出来，我们将整个函数命名为getWeight()</p><p> Also take a look at the magic weight numbers: 1, 2 and 4. Simply reading these numbers without knowing the whole story does not provide useful information. Fortunately ES2015 allows to declare const read-only references, so you can easily create constants with meaningful names to knockout the magic numbers.</p><p>另外我们来看一下整个功能大小的值：1,2,4.显然这些书和整个函数功能没有任何关系。正好ES2015提供了声明const的引用，因此可以轻松的创建一个常量去声明这些固定的值。</p><p>Let’s create the small function getWeightByType() and improve getCollectionWeight() accordingly:</p><p>让我们来创建一个更小的函数getWeightByType() 并优化一下getCollectionWeight() 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> // Code extracted into getWeightByType()</span><br><span class="line">function getWeightByType(value) &#123;  </span><br><span class="line">    const WEIGHT_NULL_UNDEFINED  = 1;</span><br><span class="line">    const WEIGHT_PRIMITIVE       = 2;</span><br><span class="line">    const WEIGHT_OBJECT_FUNCTION = 4;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        return WEIGHT_NULL_UNDEFINED;</span><br><span class="line">    &#125; </span><br><span class="line">    if (typeof value === &apos;object&apos; || typeof value === &apos;function&apos;) &#123;</span><br><span class="line">        return WEIGHT_OBJECT_FUNCTION;</span><br><span class="line">    &#125;</span><br><span class="line">    return WEIGHT_PRIMITIVE;</span><br><span class="line">&#125;</span><br><span class="line">function getCollectionWeight(collection) &#123;  </span><br><span class="line">    let collectionValues;</span><br><span class="line">    if (collection instanceof Array) &#123;</span><br><span class="line">        collectionValues = collection;</span><br><span class="line">    &#125; else if (collection instanceof Map) &#123;</span><br><span class="line">        collectionValues = [...collection.values()];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        collectionValues = Object.keys(collection).map(function (key) &#123;</span><br><span class="line">            return collection[key];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return collectionValues.reduce(function(sum, item) &#123;</span><br><span class="line">        return sum + getWeightByType(item);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">let myArray = [null, &#123; &#125;, 15];  </span><br><span class="line">let myMap = new Map([ [&apos;functionKey&apos;, function() &#123;&#125;] ]);  </span><br><span class="line">let myObject = &#123; &apos;stringKey&apos;: &apos;Hello world&apos; &#125;;  </span><br><span class="line">getCollectionWeight(myArray);  // =&gt; 7 (1 + 4 + 2)  </span><br><span class="line">getCollectionWeight(myMap);    // =&gt; 4  </span><br><span class="line">getCollectionWeight(myObject); // =&gt; 2</span><br></pre></td></tr></table></figure><p>Looks better, right? </p><p>看起来好一点了，对吧？</p><p>getWeightByType() function is an independent component that simply determines the weight by type. And reusable, as you can execute it in any other function.</p><p>getWeightByType() 这个函数独立成一个部件，能够计算出当前的类型，可复用，你可以在其他任何函数里面调用。</p><p>getCollectionWeight() becomes a bit lighter.</p><p>getCollectionWeight()变得轻巧了很多。</p><p>WEIGHT_NULL_UNDEFINED, WEIGHT_PRIMITIVE and WEIGHT_OBJECT_FUNCTION are selfexplanatory constants that describe the type weights. You don’t have to guess what 1,2 and 4 numbers mean.</p><p>三个常量的声明似乎描述的更语义化，你不需要去猜测这几个值的意思。</p><h3 id="Step-2-Continue-splitting-and-make-it-extensible-继续分割，让它可扩展"><a href="#Step-2-Continue-splitting-and-make-it-extensible-继续分割，让它可扩展" class="headerlink" title="Step 2: Continue splitting and make it extensible 继续分割，让它可扩展"></a>Step 2: Continue splitting and make it extensible 继续分割，让它可扩展</h3><p>However the updated version still has drawbacks.</p><p>然而修改之后的版本仍有缺陷。</p><p>Imagine that you have the plan to implement the weight evaluation of a Set or even other custom collection. getCollectionWeight() will grow fast in size, because it contains the logic of collecting the values.</p><p>我们可以想象我们可能要扩展计算的值的数据类型比如set或者其他自定义的集合类型，getCollectionWeight()的体积也会变大，因此我们需要一个计算集合值的逻辑。</p><p>Let’s extract into separated functions the code that gathers values from maps getMapValues() and plain JavaScript objects getPlainObjectValues(). Take a look at the improved version: </p><p>让我们开始分割函数吧。函数getMapValues()和getPlainObjectValues()分别计算两种值。让我们看一下分割之后的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function getWeightByType(value) &#123;  </span><br><span class="line">    const WEIGHT_NULL_UNDEFINED = 1;</span><br><span class="line">    const WEIGHT_PRIMITIVE = 2;</span><br><span class="line">    const WEIGHT_OBJECT_FUNCTION = 4;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        return WEIGHT_NULL_UNDEFINED;</span><br><span class="line">    &#125; </span><br><span class="line">    if (typeof value === &apos;object&apos; || typeof value === &apos;function&apos;) &#123;</span><br><span class="line">        return WEIGHT_OBJECT_FUNCTION;</span><br><span class="line">    &#125;</span><br><span class="line">    return WEIGHT_PRIMITIVE;</span><br><span class="line">&#125;</span><br><span class="line">// Code extracted into getMapValues()</span><br><span class="line">function getMapValues(map) &#123;  </span><br><span class="line">    return [...map.values()];</span><br><span class="line">&#125;</span><br><span class="line">// Code extracted into getPlainObjectValues()</span><br><span class="line">function getPlainObjectValues(object) &#123;  </span><br><span class="line">    return Object.keys(object).map(function (key) &#123;</span><br><span class="line">        return object[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function getCollectionWeight(collection) &#123;  </span><br><span class="line">    let collectionValues;</span><br><span class="line">    if (collection instanceof Array) &#123;</span><br><span class="line">        collectionValues = collection;</span><br><span class="line">    &#125; else if (collection instanceof Map) &#123;</span><br><span class="line">        collectionValues = getMapValues(collection);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        collectionValues = getPlainObjectValues(collection);</span><br><span class="line">    &#125;</span><br><span class="line">    return collectionValues.reduce(function(sum, item) &#123;</span><br><span class="line">        return sum + getWeightByType(item);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">let myArray = [null, &#123; &#125;, 15];  </span><br><span class="line">let myMap = new Map([ [&apos;functionKey&apos;, function() &#123;&#125;] ]);  </span><br><span class="line">let myObject = &#123; &apos;stringKey&apos;: &apos;Hello world&apos; &#125;;  </span><br><span class="line">getCollectionWeight(myArray);  // =&gt; 7 (1 + 4 + 2)  </span><br><span class="line">getCollectionWeight(myMap);    // =&gt; 4  </span><br><span class="line">getCollectionWeight(myObject); // =&gt; 2</span><br></pre></td></tr></table></figure><p>If you read getCollectionWeight() now, you ﬁnd much easier ﬁgure out what it does. It looks like an interesting story.</p><p>当你现在再来阅读getCollectionWeight()这个函数的时候，你会发现你能轻而易举的发现函数到底在做什么。非常有趣的变化。</p><p>Every function is obvious and straightforward. You don’t waste time digging to realize what the code does. That’s how the clean code should be.</p><p>每一个函数都清晰直观，你不用花时间去研究他在做什么，这就是精干的代码应该有的样子。</p><h3 id="Step-3-Never-stop-to-improve不要停止重构"><a href="#Step-3-Never-stop-to-improve不要停止重构" class="headerlink" title="Step 3: Never stop to improve不要停止重构"></a>Step 3: Never stop to improve不要停止重构</h3><p>Even at this step you have a lot of space for improvement! </p><p>每一个逻辑都有优化的空间。</p><p>You can create getCollectionValues() as a separated function, which contains the if/else statements to differentiate the collection types:</p><p>你可以创建一个函数 getCollectionValues()作为独立的模块。用来通过判定语句区分不同的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getCollectionValues(collection) &#123;  </span><br><span class="line">    if (collection instanceof Array) &#123;</span><br><span class="line">        return collection;</span><br><span class="line">    &#125;</span><br><span class="line">    if (collection instanceof Map) &#123;</span><br><span class="line">        return getMapValues(collection);</span><br><span class="line">    &#125;</span><br><span class="line">    return getPlainObjectValues(collection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then getCollectionWeight() would become truly plain, because the only thing it needs to do is: get the collection values getCollectionValues() and apply the sum reducer on it.</p><p>getCollectionWeight()也因为只需要做一件事情而变得真正的纯粹：获取getCollectionValues()函数返回的值，并将其累加起来<br>。<br>You can also create a separated reducer function: </p><p>你也可以创建一个迭代函数循环的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function reduceWeightSum(sum, item) &#123;  </span><br><span class="line">    return sum + getWeightByType(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because ideally getCollectionWeight() should not define functions.</p><p>因为其实理想的getCollectionWeight()函数内是不应该去定义任何函数的。</p><p>In the end the initial big function is transformed into the following small functions:</p><p>最后我们来看，最初这个庞大的函数被我们转换成了一个个小函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function getWeightByType(value) &#123;  </span><br><span class="line">    const WEIGHT_NULL_UNDEFINED = 1;</span><br><span class="line">    const WEIGHT_PRIMITIVE = 2;</span><br><span class="line">    const WEIGHT_OBJECT_FUNCTION = 4;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        return WEIGHT_NULL_UNDEFINED;</span><br><span class="line">    &#125; </span><br><span class="line">    if (typeof value === &apos;object&apos; || typeof value === &apos;function&apos;) &#123;</span><br><span class="line">        return WEIGHT_OBJECT_FUNCTION;</span><br><span class="line">    &#125;</span><br><span class="line">    return WEIGHT_PRIMITIVE;</span><br><span class="line">&#125;</span><br><span class="line">function getMapValues(map) &#123;  </span><br><span class="line">    return [...map.values()];</span><br><span class="line">&#125;</span><br><span class="line">function getPlainObjectValues(object) &#123;  </span><br><span class="line">    return Object.keys(object).map(function (key) &#123;</span><br><span class="line">        return object[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function getCollectionValues(collection) &#123;  </span><br><span class="line">    if (collection instanceof Array) &#123;</span><br><span class="line">        return collection;</span><br><span class="line">    &#125;</span><br><span class="line">    if (collection instanceof Map) &#123;</span><br><span class="line">        return getMapValues(collection);</span><br><span class="line">    &#125;</span><br><span class="line">    return getPlainObjectValues(collection);</span><br><span class="line">&#125;</span><br><span class="line">function reduceWeightSum(sum, item) &#123;  </span><br><span class="line">    return sum + getWeightByType(item);</span><br><span class="line">&#125;</span><br><span class="line">function getCollectionWeight(collection) &#123;  </span><br><span class="line">    return getCollectionValues(collection).reduce(reduceWeightSum, 0);</span><br><span class="line">&#125;</span><br><span class="line">let myArray = [null, &#123; &#125;, 15];  </span><br><span class="line">let myMap = new Map([ [&apos;functionKey&apos;, function() &#123;&#125;] ]);  </span><br><span class="line">let myObject = &#123; &apos;stringKey&apos;: &apos;Hello world&apos; &#125;;  </span><br><span class="line">getCollectionWeight(myArray);  // =&gt; 7 (1 + 4 + 2)  </span><br><span class="line">getCollectionWeight(myMap);    // =&gt; 4  </span><br><span class="line">getCollectionWeight(myObject); // =&gt; 2</span><br></pre></td></tr></table></figure><p>That’s the art of writing small and plain functions!</p><p>这就是编写小而单纯的函数的艺术！</p><p>After all these code quality optimizations, you get a bunch of nice benefits:</p><p>通过以上所有的这些代码质量的优化，你可以收获很多益处：</p><ul><li>The readability of getCollectionWeight() increased by self-explanatory code </li><li>The size of getCollectionWeight() reduced considerable getCollectionWeight() function is now protected from fast growth if you plan to implement the weight calculation of other collection types </li><li>The extracted functions are now decoupled and reusable components. Your colleague may ask you to import these nice functions into another project: and you can easily do that If accidentally a function generates an error, the call stack will be more precisebecause it contains the function names. </li><li>Almost instantly you could determine the function that makes problems The split functions are much easier to test and reach a high level of code coverage. Instead of testing one big function with all possible scenarios, you can structure your tests and verify each small function separately       </li><li>You can benefit from CommonJS or ES2015 modules format. Create from extracted functions separated modules. This makes your project files lightweight and structured.</li><li>自解释代码使函数getCollectionWeight()的可读性大大增强了<ul><li>函数getCollectionWeight()的体积明显减小了</li><li>当你添加判定值的数量的时候，函数getCollectionWeight()保持稳定的增长的速度。</li><li>分离出来的代码成为具有低耦合性和可复用性的组件。你的同事或许会请求你将这些非常棒的小组件应用到其他项目中去，这是轻而易举就可以实现的。</li><li>如果一旦有代码报错，报错堆栈更清晰因为他包含了函数的具体名称。你可以轻而易举的判定出出错的部分。分割出来的代码更易测试并且可以达到一个很高的测试覆盖率，从而使代码的可测试性提高。相比于这个，测试巨大的函数是很糟糕的。你可以为每一个函数构造测试并且独立的进行验证工作。</li><li>你可以按照CommonJS或者ES2015的模式去构造你的函数，将其分割成独立的小函数。这会使你的项目文件变得更加轻量和更有结构。<br>These advantages help you survive in the complexity of the applications.<br>这些优点将你从复杂的应用中拯救出来。</li></ul></li></ul><p>As a general rule, your functions should not be longer than 20 lines of code. Smaller - better.</p><p>通常的规则是你的函数不应该超过20行，并且越小越好。</p><p>I think now you want to ask me a reasonable question: “I don’t want to create functions for each line of code. Is there a criteria when I should stop splitting?” This is a subject of the next chapter.</p><p>我想你现在有一个情理之中的问题想要问我：“让我为每一个函数写一行代码我是极不情愿的。请问对于拆分的原则有什么标准么？”这将会是我们下一个环节要解答的问题。</p><h3 id="2-Functions-should-be-plain-函数功能要单一"><a href="#2-Functions-should-be-plain-函数功能要单一" class="headerlink" title="2. Functions should be plain   函数功能要单一"></a>2. Functions should be plain   函数功能要单一</h3><p>Let’s relax a bit and think what is actually a software application?</p><p>让我们稍微放松一下然后仔细想想应用软件的实质是什么？</p><p>Every application is implementing a list of requirements. The role of developer is to divide these requirements into small executable components (namespaces, classes, functions, code blocks) that do a well determined task.</p><p>每个应用在本质上都是对一系列需求的实现，而开发者所扮演的角色就是将这些需求拆分成更小的可执行的可以更好的完成自身任务的模块（命名空间，类，函数，代码块）</p><p>A component consists of other smaller components. If you want to code a component, you need to create it from components at only one level down in abstraction.</p><p>一个组件包含了其他更小的组件们。如果你想编写编写其中一个组件，你需要将他从其他你创作的同一级别的组件中中抽象出来。</p><p>In other words, what you need is to decompose a function into smaller steps, but keep these steps at the same, one step down, level of abstraction. This is important because it makes the function plain and implies to “do one thing and do it well”.</p><p>换句话说，你需要做的就是将这些功能拆分成更小的步骤，但是需要保证这些小步骤是同样的，同一级别的，同等水平的抽象。这是非常重要的因为只有这样你才能使你的函数功能单一并且意味着你成功实现了“做一件事情并且把它做好”。</p><p>Why is this necessary? Because plain functions are obvious. Obvious means easy to read and modify.</p><p>说了这么多，为什么功能单一的代码是很重要的呢？因为清晰的代码的功能是显而易见的。而显而易见则意味着代码的易读性和易修改性。</p><p>Let’s follow an example. Suppose you want to implement a function that keeps onlyprime numbers (2, 3, 5, 7, 11, etc) in an array, removing non prime ones (1, 4, 6, 8, etc). The function is invoked this way:</p><p>让我们再来看一个例子。假设你想实现一个函数：去除数组中的合数（例如1,4,6,8等）而只保留其中的质数（例如2,3,5,7,11等等）。这个函数将会被这样调用：</p><p><code>getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&gt; [2, 3, 5, 11]</code></p><p>What are steps at one level down in abstraction to implement the functiongetOnlyPrime()? Let’s formulate this way:</p><p>那么函数getOnlyPrime()的实现在同一个抽象级别的步骤有多少呢？让我们一起用下面这种方式一步一步来实现;</p><p>To implement getOnlyPrime() function, filter the array of numbers using isPrime()function.</p><p>为了实现函数getOnlyPrime()，我们首先使用isPrime()函数来对数组中的数据进行过滤</p><p>Simply, just apply a filter function isPrime() over the array of numbers.</p><p>简单来说，就是创建一个过滤器函数isPrime() 对数组成员进行过滤。</p><p>Do you need to implement the details of isPrime() at this level? No, becausegetOnlyPrime() function would have steps from different level of abstractions. The function would take too much responsibility.</p><p>你需要的做的只是在这个抽象级别上实现isPrime() 的细节？不，你错了。因为getOnlyPrime()函数会有很多不同级别的抽象。这个函数包含太多的任务在身。</p><p>Having the plain idea in mind, let’s implement the body of getOnlyPrime() function:</p><p>在你的头脑中想象一下如何让这个函数变的单一。接下来让我们一起来实现getOnlyPrime()这个函数的主体部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getOnlyPrime(numbers) &#123;  </span><br><span class="line">        return numbers.filter(isPrime);</span><br><span class="line">&#125;</span><br><span class="line">getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&gt; [2, 3, 5, 11]</span><br></pre></td></tr></table></figure><p>As you can see, getOnlyPrime() is plain and simple. It contains steps from a single level of abstraction: .filter() array method and isPrime().</p><p>正如你所看到的一样，getOnlyPrime()这个函数是短小而又单一的。它包含了一个单一抽象级别的函数:.filter()数组方法isPrime（）</p><p>Now is the time move one level down in abstraction.</p><p>现在是时候再降低一下函数的抽象级别了。</p><p>The array method .filter() is provided by JavaScript engine and use it as is. Of course the standard describes exactly what it does.</p><p> .filter()这个方法提供了一个原生的javascript引擎。当然标准的描述是他做了什么。</p><p>Now you can detail into how isPrime() should be implemented:</p><p>现在你可以具体研究 isPrime()应该怎样被实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To implement isPrime() function that checks if a number n is prime, verify if any number from 2 to Math.sqrt(n) evenly divides n.</span><br><span class="line">实现isPrime()这个函数就是要检查一个数n是否是素数，依次判断从2开始到√n之间的任何一个整数能否被n整除。</span><br></pre></td></tr></table></figure></p><p>Having this algorithm (yet not efficient, but used for simplicity), let’s code isPrime()function:</p><p>使用已有的算法来实现isPrime()函数（虽然效率不高，但是调用却很简单）。让我们一起来编写它的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function isPrime(number) &#123;  </span><br><span class="line">    if (number === 3 || number === 2) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (number === 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let divisor = 2; divisor &lt;= Math.sqrt(number); divisor++) &#123;</span><br><span class="line">        if (number % divisor === 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">function getOnlyPrime(numbers) &#123;  </span><br><span class="line">    return numbers.filter(isPrime);</span><br><span class="line">&#125;</span><br><span class="line">getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&gt; [2, 3, 5, 11]</span><br></pre></td></tr></table></figure><p>getOnlyPrime() is small and plain. It has only strictly necessary steps from one level down in abstraction.</p><p>getOnlyPrime()是小而单一的。它只有一个小于一个抽象级别的必要的步骤。</p><p>The readability of complex functions can be much improved if you follow the rule of making them plain. Having each level of abstraction coded precisely prevents the creation of big chunks of unmaintainable code.</p><p>如果你能按照这样的规则去使自己的代码的功能变得单一，那个抽象复杂的函数的可读性将会被大大的提高。对每一个抽象级别进行编码会很好的防止大的可维护性差的代码的产生。</p><h3 id="3-Use-concise-function-names使用简洁清晰的函数命名"><a href="#3-Use-concise-function-names使用简洁清晰的函数命名" class="headerlink" title="3. Use concise function names使用简洁清晰的函数命名"></a>3. Use concise function names使用简洁清晰的函数命名</h3><p>Function names should be concise: no more and no less. Ideally the name suggests clearly what the function does, without the necessity to dive into the implementation details.</p><p>函数命名应该是简洁明了的：不多不少。理想的命名应该是可以清楚地告诉人们这个函数实现了怎样的功能，没有必要再将它拆分成更小的细节去实现。</p><p>For function names use camel case format that starts with a lowercase letter: addItem(),saveToStore() or getFirstName().</p><p>函数命名一般会使用驼峰命名法——以小写字母开头，例如：addItem(),saveToStore() or    getFirstName().</p><p>Because functions are actions, the name should contain at least one verb. For example deletePage(), verifyCredentials(). To get or set a property, use the standard set and getprefixes: getLastName() or setLastName().</p><p>因为函数是一种功能的实现，所以命名至少应该是包含一个动词。例如deletePage(), verifyCredentials().如果是为了设置或者是获取属性值，那个可以使用标准的set和get作为前缀：getLastName() 或者setLastName().</p><p>Avoid in the production code misleading names like foo(), bar(), a(), fun(), etc. Such names have no meaning.</p><p>并且要防止使用类似 foo(), bar(), a(), fun()等等的命名将我们带入歧途。这样的命名是无意义的。</p><p>If functions are small and plain, names are concise: the code is read as a wonderful prose.<br>如果你的函数是小而单一并且命名简洁的，这意味着读你的代码就像是在读一篇美妙的散文一样令人赏心悦目。</p><h3 id="4-Conclusion结论"><a href="#4-Conclusion结论" class="headerlink" title="4. Conclusion结论"></a>4. Conclusion结论</h3><p>Certainly the provided examples are quite simple. Real world applications are more complex. You may complain that writing plain functions, with only one level down in abstraction, is a tedious task. But it’s not that complicated if your practice right from the start of the project.</p><p>当然啦，上文提到的例子都是相当简单的。真实的应用都是相当复杂的。或许你会抱怨，这样将在同一个抽象级别的函数写的单一是一件很枯燥乏味的工作。但是如果你从开始你的项目的时候就正确的练习那将一点儿都不困难。</p><p>If an application already has functions with too much responsibility, you may find hard to reorganize the code. And in many cases impossible to do in a reasonable amount of time. At least start with small: extract something you can.</p><p>如果一个应用已经有了太多复杂的函数，你或许会发现去重构这个代码是很困难的。并且在很多情况下重构这些代码会花去超出预期的时间。至少，从小功能开始：拆分那些你可以拆分的。</p><p>Of course the correct solution is to implement the application correctly from the start. And dedicate time not only to implementation, but also to a correct structure of your functions: as suggested make them small and plain.</p><p>当然最好的解决方法就是你从项目最开始就正确的实现这些应用。其实你花费时间最多的不光是如何实现这些功能，还有就是你的函数有没有一个正确的结构：就像我所建议的，让你的代码短小精悍。</p><p><code>Measure seven times, cut once.</code></p><p>ES2015 implements a nice module system, that clearly suggest that small functions are a good practice.</p><p>ES2015定义了一个很棒的模块系统，其中清楚地建议我们实现小功能是一个很好的练习方式。</p><p>Just remember that clean and organized code always deserves investing time. You may find it hard to do. You may need a lot of practice. You may come back and modify a function multiple times.</p><p>你只需要记住清晰有条理的代码总是值得我们花费更多的时间。或许开始的时候你会觉得这很困难，但是或许你需要的只是多加练习。或许你会有很多次回过头来看你之前编写的代码并且重构他们的一个功能很多次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nothing can be worse than messy code.</span><br><span class="line">没有什么能比糟糕的代码更糟糕的了。</span><br></pre></td></tr></table></figure><p>What practice do you use to make the code organized? Feel free to write a comment bellow!</p><p>在你的日常编码过程中你是如何练习把你的代码写的调理清晰的呢？放轻松，在下面留下你的留言吧~！</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github博客搭建</title>
      <link href="/2016/08/27/180227blog/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    作为一个技术开发人员，拥有一个属于自己的csdn、博客园等之外的完全属于自己的网站，好像也是一个必需的技能呢，之前大家可能都会使用wordpress、jekyll等搭建自己的博客，但是现在使用开源的github网站和hexo也可以轻松实现，而且重要的是不要花费金钱来购买域名或者服务器哦！大概是贫穷限制了我的想象力。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p><contents></contents></p><p></p><p style="text-indent: 40px"></p><h3 id="1-博客的搭建"><a href="#1-博客的搭建" class="headerlink" title="1.博客的搭建"></a>1.博客的搭建</h3><p>网址：<br><a href="http://www.jianshu.com/p/13e64c9e2295" target="_blank" rel="noopener">http://www.jianshu.com/p/13e64c9e2295</a><br>这篇文章可以说是讲的非常好，非常详细，按照这个步骤就能一步步的搭建好自己的个人博客。其中几个我们可能会出问题的点儿，该作者都详细的做了解释和解决方法。</p><p>需要注意的点</p><ul><li>启动hexo服务器的时候，所在的目录为blog目录下。不然会提示你hexo可能没有这种用法。</li><li>启动命令是<code>hexo s</code>不是<code>hexo --server</code>也不是<code>hexo -s</code>，因为习惯的原因，我很容易写成后两种形式。</li><li>⚠️一定要在github中为你的博客创建仓库和分支，不然到时候你的电脑出了什么问题，或者文件不小心删除，你是找不回你的原本的文章的哦。这样也可以方便的迁移哦～</li><li>另外，如果你像我一样使用yelee主题的话，它有两个_config.xml文件哦，记得两个文件都要简单配置一下下哦，不然可能有些功能无法使用哦～<h3 id="2-主题"><a href="#2-主题" class="headerlink" title="2.主题"></a>2.主题</h3>网址：<br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a><br>从中发现几个我个人觉得还不错的主题</li><li>next(<a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">http://theme-next.iissnan.com</a>)</li><li>minos(<a href="https://github.com/ppoffice/hexo-theme-minos" target="_blank" rel="noopener">https://github.com/ppoffice/hexo-theme-minos</a>)</li><li>icarus(<a href="https://github.com/digitalcraftsman/hugo-icarus-theme" target="_blank" rel="noopener">https://github.com/digitalcraftsman/hugo-icarus-theme</a>)</li><li>yelee(<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">http://moxfive.coding.me/yelee/</a>)</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的猫</title>
      <link href="/2016/07/30/mycat/"/>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    谨以此文纪念我曾经可爱乖巧的猫儿<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p><contents></contents></p><p style="text-indent: 40px">最近偶然看到顾湘的《好小猫》，愈发想自己养一只猫。自小喜猫，却因为妈妈的缘故，始终未曾养过，只在13岁的时候，小姨的婆家知我喜猫，从邻居家抱来一只1月大的小奶猫，印象中黑白花纹，两只眼睛周围黑个高，像只熊猫。一路上又顺路去了别人家，我只小心翼翼的抱着她，她也乖乖的在我怀里安稳的睡觉。那时的条件并没有想到要给她买猫粮，只是会用小碟子给她冲一些豆奶，她也乖乖的喝下，慢慢的和我熟络起来。学校离家很近，只有几分钟距离，放学以后，急匆匆回来和她玩耍，她很乖也很有灵气，抓着她的两只前爪，整个身体缩成一个球，甚是可爱。某天晚上，我一边和猫玩耍，一边和妈妈撒娇，让她晚上和我睡觉吧，我妈勉强同意，我高兴的很，把猫抱进被窝里，安心的睡了……第二天起来，只有台阶上的斑斑血迹，寻遍家里何处，也未曾寻不见我的猫，我只是一直的哭，我的猫，我和她只有5天的缘分。我还没有真的养猫，就失去了我最爱的猫。后面，在邻居家，在亲朋好友那里，也曾见到温驯可爱的猫，却再也没有我的猫那样招我喜爱。我一直很恨我自己，或许如果那天不是我坚持和猫一起睡觉，半夜里，她就不会被我妈抱出去留在门外，她才1月大，是我害死了她。自那之后，小学毕业，我还是住宿生活，从一个星期，到两个星期，到半年才回一次家，再也没有养过猫。如今，我很想念我的猫，想养一只猫，只是怕，上班不在家的我，如何照料好我的猫，只怕她终日寂寞孤苦，空惹一生感情。</p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人原创片段</title>
      <link href="/2015/03/30/myself/"/>
      <content type="html"><![CDATA[<p></p><p style="text-indent: 40px">我不是一个聪明的人，总是随心所欲，跟着感觉走。不是一个漂亮的人，每次想自拍的时候都发现原来自己长得这么丑。我不是一个认真的人，答应自己的事情，总是完不成。人丑还须多读书。我有点小骄傲，有些小任性，爱耍小脾气。我不会说话，不喜欢去伪装，有什么情绪都写在脸上。回顾过去的这些年，很多人渐渐在我生活中失去了踪影，但是也有他们，不管发生了什么，都会站在我这边，默默的支持我。感谢妈妈，给与我生命，感受这个世界的悲欢离合；感谢朋友们，让我在有生之年和你们一起欢笑一起哭泣一起成长；感谢我自己，虽然迷茫，但却还坚强的任性的执着的享受着这个世界带给你的一切。</p>]]></content>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
